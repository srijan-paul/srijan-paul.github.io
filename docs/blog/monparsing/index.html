<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
    <meta name="description" content="Using monads to write parser combinators in Haskell"></meta>
    <meta property="og:title" content="Monadic parser combinators"></meta>
    <meta property="twitter:title" content="Monadic parser combinators"></meta>
    <meta property="twitter:description" content="Using monads to write parser combinators in Haskell"></meta>

     
    <meta property="og:image" content></meta>
		<meta name="twitter:image" content>
    

    <meta property="og:site_name" content="InJuly"></meta>

    <link rel="stylesheet" href="/assets/css/common.css">
    <link rel="stylesheet" href="/assets/css/post.css">
    <link rel="stylesheet" href="/assets/css/theme.css">
    

    <script data-goatcounter="https://injuly.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>


    <title>Monadic parser combinators</title>
  </head>

  <body>
    <div class="main">
      <div class="nav-container">
        <nav>
          <a href="/" class="nav-link">index</a>
          <a href="/about" class="nav-link">about</a>
          <a href="/blog" class="nav-link active-nav-link">blog</a>
          <a href="/now" class="nav-link">now</a>
        </nav>
      </div>

      <div class="leader">
        <h1> Monadic parser combinators </h1>
				<div class="post-date"> May 05 </div>
        <div class="tags" id="tags">
            <a class="tag" href="/tags/FP.html">FP</a>
            <a class="tag" href="/tags/programming-languages.html">programming-languages</a>
            <a class="tag" href="/tags/haskell.html">haskell</a>
        </div>
      </div>
      <p>A <a href="https://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf">Parser combinator</a>, as wikipedia describes it,
is a <em>higher-order function that accepts several parsers as input and returns a new parser as its output</em>.</p>
<p>They can be very powerful when you want to build modular parsers and leave them open for further extension.
But it can be tricky to get the error reporting right when using a 3<sup>rd</sup> party combinator library, and they tend to be slower in imperative languages.
Nonetheless, it is an interesting cornerstone in functional programming and <a href="https://en.wikipedia.org/wiki/Programming_language_theory">PLT</a>, so it shouldn&#39;t hurt to learn about them by building one on our own.</p>
<p>We&#39;re going to start by writing a library that describes several tiny parsers and functions that operate on those parsers.
Then, we&#39;re going to build some parsers to demonstrate the usefulness of our work.</p>
<p>To give you a small flash forward, here is a parser that accepts C-style identifiers,
written with the help of our handy combinators:</p>
<code class="language-haskell"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="co">-- matches strings that satisfy [a-zA-Z][a-zA-Z0-9]+</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">ident ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="co">-- One letter or &#39;_&#39;, followed by zero of more &#39;_&#39;, letters or digits</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>ident <span class="ot">=</span> alpha_ <span class="ot">`thenList`</span> many&#39; (alpha_ <span class="op">&lt;|&gt;</span> digit)</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    alpha_ <span class="ot">=</span> letter <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;_&#39;</span></span></code></pre></div></code></pre>
<p>It is recommended for you to have some basic understanding of:</p>
<ul>
<li>Parsers
</li>
<li>Monads in functional programming
</li>
<li>Haskell
</li>
</ul>
<p>This post is a derivative of two papers I had read recently (<a href="https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">1</a>, <a href="https://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf">2</a>).
If you like a denser reading, you can go through the papers instead.
The full code for this blog can be found <a href="https://gist.github.com/srijan-paul/87abfeacb84f0d862d093b3ae899cf67">here on GitHub</a>.</p>
<h2 id="the-parser-type">The Parser type</h2>
<p>Before we begin to define combinators that act on parsers,
we must choose a representation for a parser first.</p>
<p>A parser takes a string and produces an output that can be just about anything.
A list parser will produce a list as it&#39;s output,
an integer parser will produce <code>Int</code>s,
a JSON parser might return a custom <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">ADT</a> representing a JSON.</p>
<p>Therefore, it makes sense to make Parser a polymorphic type.
It also makes sense to return a list of results instead of a single result
since grammar can be ambiguous, and there may be several ways to parse the same input string.</p>
<p>An empty list, then, implies the parser failed to parse the provided input. (<a href="#backmatter">1</a>)</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="ot">=</span> <span class="dt">Parser</span> {<span class="ot"> parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(a, <span class="dt">String</span>)] }</span></code></pre></div></code></pre>
<p>You might wonder why we return the tuple <code>(a, String)</code>, not just <code>a</code>.
Well, a parser might not be able to parse the entire input string.
Often, a parser is only intended to parse some prefix of the input, and let another parser do the rest of the parsing.
Thus, we return a pair containing the parse result <code>a</code> and the unconsumed string subsequent parsers can use.</p>
<p>We could have used the <code>type</code> keyword let <code>Parser</code> be an alias for <code>String -&gt; [(a, String)]</code>,
but having a unique data type lends us the ability to instantiate it as a typeclass,
which is something we&#39;ll do later on.</p>
<h2 id="baby-parsers">Baby parsers</h2>
<p>We can start by describing some basic parsers that do very little work.
A <code>result</code> parser always succeeds in parsing without consuming the input string.</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">result ::</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>result val <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \inp <span class="ot">-&gt;</span> [(val, inp)]</span></code></pre></div></code></pre>
<p>The parser <code>zero</code> will always fail by returning an empty list.</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">zero ::</span> <span class="dt">Parser</span> a</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>zero <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> <span class="fu">const</span> []</span></code></pre></div></code></pre>
<p><code>item</code> unconditionally accepts the first character of any input string.</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">item ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>item <span class="ot">=</span> <span class="dt">Parser</span> parseItem</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    parseItem [] <span class="ot">=</span> []</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    parseItem (x<span class="op">:</span>xs) <span class="ot">=</span> [(x, xs)]</span></code></pre></div></code></pre>
<p>Let&#39;s try some of these parsers in GHCi:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse (result <span class="dv">42</span>) <span class="st">&quot;abc&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">42</span>, <span class="st">&quot;abc&quot;</span>)]</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse item <span class="st">&quot;abc&quot;</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>[(<span class="ch">&#39;a&#39;</span>, <span class="st">&quot;bc&quot;</span>)]</span></code></pre></div></code></pre>
<h2 id="building-parsers-on-demand">Building parsers on demand</h2>
<p>The basic parsers we defined above are of very little use.
Ideally, we would want parsers that accept input strings that satisfy certain constraints.
Say we want a parser that consumes a string if its first character satisfies a predicate.
We can generalize this idea by writing a function that takes a <code>(Char -&gt; Bool)</code> predicate and returns a parser that only consumes an input string if its first character returns <code>True</code> when supplied to the predicate.</p>
<p>The simplest solution for this would be:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">sat ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>sat p <span class="ot">=</span> <span class="dt">Parser</span> parseIfSat</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    parseIfSat (x <span class="op">:</span> xs) <span class="ot">=</span> <span class="kw">if</span> p x <span class="kw">then</span> [(x, xs)] <span class="kw">else</span> []</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    parseIfSat [] <span class="ot">=</span> []</span></code></pre></div></code></pre>
<p>However, since we already have an <code>item</code> parser that unconditionally extracts
the first character from a string, we could use this as an opportunity to create a basic parser combinator.</p>
<p>Before writing a combinator, we must first instantiate <code>Parser</code> as a <code>Monad</code>. (<a href="#backmatter">2</a>)</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  p <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \inp <span class="ot">-&gt;</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">concat</span> [parse (f v) inp&#39; <span class="op">|</span> (v, inp&#39;) <span class="ot">&lt;-</span> parse p inp]</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- a -&gt; Parser a</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="ot">=</span> result</span></code></pre></div></code></pre>
<p>The <code>bind</code> operation takes a <code>Parser a</code> (p) and a function <code>a -&gt; Parser b</code> (f), and returns a <code>Parser b</code>.
The idea is to apply <code>p</code>, if it fails, then we have an empty list which results in <code>concat [[]]</code> = <code>[]</code>.
If <code>p</code> successfully parses <code>inp</code> into one or more possible parse results,
we apply <code>f</code> to each of the results to get corresponding <code>Parser b</code>s and then apply those to the rest of the input.</p>
<p>With this new extension, our <code>sat</code> parser can be re-written as:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>sat p <span class="ot">=</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Apply `item`, if it fails on an empty string, we simply short circuit and get `[]`.</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  item <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> p x</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> result x</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> zero</span></code></pre></div></code></pre>
<p>Now we can use the <code>sat</code> combinator to describe several useful parsers.
For example, a <code>char</code> parser that only consumes a string beginning with a specific character.</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>char x <span class="ot">=</span> sat (<span class="op">==</span> x)</span></code></pre></div></code></pre>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse (char <span class="ch">&#39;a&#39;</span>) <span class="st">&quot;abc&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>[(<span class="ch">&#39;a&#39;</span>, <span class="st">&quot;bc&quot;</span>)]</span></code></pre></div></code></pre>
<p>A parser for ASCII digits:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="co">-- import Data.Char (isDigit, isLower, isUpper)</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">digit ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>digit <span class="ot">=</span> sat <span class="fu">isDigit</span></span></code></pre></div></code></pre>
<p>And similarly small but useful parsers:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">lower ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>lower <span class="ot">=</span> sat <span class="fu">isLower</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="ot">upper ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>upper <span class="ot">=</span> sat <span class="fu">isUpper</span></span></code></pre></div></code></pre>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> ghci <span class="op">-</span>i main<span class="op">.</span>hs</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse lower <span class="st">&quot;aQuickBrownFox&quot;</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>[(<span class="ch">&#39;a&#39;</span>,<span class="st">&quot;QuickBrownFox&quot;</span>)]</span></code></pre></div></code></pre>
<p>Now that we have <code>upper</code>, <code>lower</code> and <code>digit</code> this opens up new possibilities for combinations:</p>
<ul>
<li>An <code>alphabet</code> parser that accepts a char that is consumable by either <code>upper</code> or <code>lower</code>.
</li>
<li>An <code>alphanumeric</code> parser that accepts a char, either <code>alphabet</code> or <code>digit</code>.
</li>
</ul>
<p>Clearly, an <code>or&#39;</code> combinator that captures this recurring pattern will come in handy.</p>
<p>Let us begin by describing a <code>plus</code> combinator that concatenates the result returned by two parsers:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Applies two parsers to the same input, then returns a list</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="co">-- containing results returned by both of them.</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">plus ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>p <span class="ot">`plus`</span> q <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \inp <span class="ot">-&gt;</span> parse p inp <span class="op">++</span> parse q inp</span></code></pre></div></code></pre>
<p>Haskell has a <a href="https://wiki.haskell.org/MonadPlus">MonadPlus</a> typeclass defined in the prelude like so:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadPlus</span> m <span class="kw">where</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">  mzero ::</span> m a</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">  mplus ::</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</span></code></pre></div></code></pre>
<p><code>mzero</code> represents failure, and <code>mplus</code> represents combination of two monads.
Since <code>Parser</code> is already a monad, we can instantiate the <code>MonadPlus</code> typeclass to enforce
this idea:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Add this to the list of imports:</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="co">-- import Control.Monad (MonadPlus (..))</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadPlus</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  mzero <span class="ot">=</span> zero</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>  mplus <span class="ot">=</span> plus</span></code></pre></div></code></pre>
<p>The <code>or&#39;</code> combinator can then be:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">or&#39; ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>p <span class="ot">`or&#39;`</span> q <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \inp <span class="ot">-&gt;</span> <span class="kw">case</span> parse (p <span class="ot">`plus`</span> q) inp <span class="kw">of</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> []</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    (x<span class="op">:</span>xs) <span class="ot">-&gt;</span> [x]</span></code></pre></div></code></pre>
<p>In fact, the <code>Alternative</code> typeclass already defines this functionality with the choice (<code>&lt;|&gt;</code>) operator:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  empty <span class="ot">=</span> zero</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&lt;|&gt;</span>) <span class="ot">=</span> or&#39;</span></code></pre></div></code></pre>
<p>Finally, we can return to the <code>letter</code> and <code>alphanum</code> parsers:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">letter ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>letter <span class="ot">=</span> lower <span class="op">&lt;|&gt;</span> upper</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="ot">alphanum ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>alphanum <span class="ot">=</span> letter <span class="op">&lt;|&gt;</span> digit</span></code></pre></div></code></pre>
<p>We can now take them for a spin in GHCi:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse letter <span class="st">&quot;p0p3y3&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>[(<span class="ch">&#39;p&#39;</span>,<span class="st">&quot;0p3y3&quot;</span>)]</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse letter <span class="st">&quot;30p3y3&quot;</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse alphanum <span class="st">&quot;foobar&quot;</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>[(<span class="ch">&#39;f&#39;</span>,<span class="st">&quot;oobar&quot;</span>)]</span></code></pre></div></code></pre>
<p>As an aside, we can use the
<a href="https://hackage.haskell.org/package/base-4.16.1.0/docs/Prelude.html#v:-62--62-">sequencing (&gt;&gt;) operator</a> to write more concise code at times.
Consider the function <code>string</code> for example, where <code>string &quot;foo&quot;</code> returns a parser that only accepts strings which begin with &quot;foo&quot;.</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>string <span class="st">&quot;&quot;</span> <span class="ot">=</span> result <span class="st">&quot;&quot;</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>string (x<span class="op">:</span>xs) <span class="ot">=</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>  char x <span class="op">&gt;&gt;</span> string xs <span class="op">&gt;&gt;</span> result (x<span class="op">:</span>xs)</span></code></pre></div></code></pre>
<p>Using <code>&gt;&gt;=</code> notation, we would have had to write:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>string (x<span class="op">:</span>xs) <span class="ot">=</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  char x</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&gt;&gt;=</span> <span class="fu">const</span> string xs <span class="co">-- same as \_ -&gt; string xs</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&gt;&gt;=</span> <span class="fu">const</span> result (x<span class="op">:</span>xs) <span class="co">-- same as \_ -&gt; result (x:xs)</span></span></code></pre></div></code></pre>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse (string <span class="st">&quot;prefix&quot;</span>) <span class="st">&quot;prefixxxxx&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>[(<span class="st">&quot;prefix&quot;</span>, <span class="st">&quot;xxxx&quot;</span>)]</span></code></pre></div></code></pre>
<h2 id="using-the-do-notation">Using the do notation</h2>
<p>Haskell provides a handy <a href="https://en.wikibooks.org/wiki/Haskell/do_notation">do notation</a>
for readably sequencing monadic computations.
This is useful when composing monadic actions becomes a bit gnarly looking.
Consider this example that composes the outputs of several parsers:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>parser <span class="ot">=</span> parser1 <span class="op">&gt;&gt;=</span> \x1 <span class="ot">-&gt;</span> <span class="co">-- 1. apply parser1</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  make_parser2 x1 <span class="op">&gt;&gt;=</span> \x2 <span class="ot">-&gt;</span> <span class="co">-- 2. use parser1&#39;s output to make parser2</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    make_parser3 x2 <span class="op">&gt;&gt;=</span> \x3 <span class="ot">-&gt;</span> <span class="co">-- 3. Use parser2&#39;s output to make parser3</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (f x1 x2 x3) <span class="co">-- 4. Combine all parse results to form the final result</span></span></code></pre></div></code></pre>
<p>Using the <code>do</code> notation, the above code snippet becomes:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>parser <span class="ot">=</span> <span class="kw">do</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  x1 <span class="ot">&lt;-</span> parser1</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  x2 <span class="ot">&lt;-</span> make_parser2 x1</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>  x3 <span class="ot">&lt;-</span> make_parser3 x2</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (f x1 x2 x3)</span></code></pre></div></code></pre>
<p>Moving forward, we will prefer the <code>do</code> notation over <code>&gt;&gt;=</code> wherever it improves readability.</p>
<h2 id="combinators-for-repetition">Combinators for repetition</h2>
<p>You may be familiar with the regex matchers <code>+</code> and <code>*</code>.
<code>a*</code> matches zero or more occurrences of the letter &#39;a&#39;, whereas <code>a+</code> expects one or more occurrences of the letter &#39;a&#39;.</p>
<p>We can represent the <code>*</code> matcher as a combinator like so:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">many&#39; ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>many&#39; p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  x  <span class="ot">&lt;-</span> p <span class="co">-- apply p once</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>  xs <span class="ot">&lt;-</span> many&#39; p <span class="co">-- recursively apply `p` as many times as possible</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (x<span class="op">:</span>xs)</span></code></pre></div></code></pre>
<p>Looks decent, but when run in GHCi, it fails to produce the expected result:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse (many&#39; <span class="op">$</span> char <span class="ch">&#39;x&#39;</span>) <span class="st">&quot;xx&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>[]</span></code></pre></div></code></pre>
<p>If you try to work out the application of this parser by hand, you&#39;ll notice a flaw in our base case:
In the final recursive call, when the input string is <code>&quot;&quot;</code>, <code>x &lt;- p</code> fails, and we short circuit to return <code>[]</code>.</p>
<p>To handle this scenario, we can use our <code>or&#39;</code> combinator:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">many&#39; ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>many&#39; p <span class="ot">=</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> p <span class="co">-- apply p once</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    xs <span class="ot">&lt;-</span> many&#39; p <span class="co">-- recursively apply `p` as many times as possible</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (x <span class="op">:</span> xs)</span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> <span class="fu">return</span> []</span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- In case `p` fails either in the initial call, or in one of the</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- recursive calls to itself, we return an empty list as the parse result.</span></span></code></pre></div></code></pre>
<p>And we&#39;re golden:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse (many&#39; <span class="op">$</span> char <span class="ch">&#39;x&#39;</span>) <span class="st">&quot;xxx123&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>[(<span class="st">&quot;xxx&quot;</span>,<span class="st">&quot;123&quot;</span>)]</span></code></pre></div></code></pre>
<p>If the use of <code>&lt;|&gt;</code> is still confusing to you, try working it out on paper.</p>
<p>Analogous to the regex <code>+</code> matcher, we can write a <code>many1</code> combinator that accepts one or more occurrences of an input sequence.
Piggybacking off of <code>many&#39;</code>, this can be simply written as:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">many1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>many1 p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> p</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>  xs <span class="ot">&lt;-</span> many&#39; p</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (x<span class="op">:</span>xs)</span></code></pre></div></code></pre>
<h2 id="parsing-a-list-of-identifiers">Parsing a list of identifiers</h2>
<p>If you haven&#39;t realized by now, we&#39;ve built some combinators capable of parsing regular languages.
Circling back to the beginning of this post, here is a combinator that parses a valid C-style identifier:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">ident ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>ident <span class="ot">=</span> <span class="kw">do</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> alpha_</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>  xs <span class="ot">&lt;-</span> many&#39; (alpha_ <span class="op">&lt;|&gt;</span> digit)</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (x <span class="op">:</span> xs)</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    alpha_ <span class="ot">=</span> letter <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;_&#39;</span></span></code></pre></div></code></pre>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse ident <span class="st">&quot;hello_123_ = 5&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>[(<span class="st">&quot;hello_123_&quot;</span>,<span class="st">&quot; = 5&quot;</span>)]</span></code></pre></div></code></pre>
<p>To make it even more concise, we can define a <code>then&#39;</code> combinator which combines
the result produced by two parsers using a caller provided function.</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">then&#39; ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> c</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>then&#39; combine p q <span class="ot">=</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  p <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    q <span class="op">&gt;&gt;=</span> \xs <span class="ot">-&gt;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>      result <span class="op">$</span> combine x xs</span></code></pre></div></code></pre>
<p>A <code>thenList</code> combinator can then combine to parse results of type <code>a</code> and <code>[a]</code> using <code>(:)</code>.</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">thenList ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span>[a] <span class="ot">-&gt;</span> <span class="dt">Parser</span>[a]</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>thenList <span class="ot">=</span> then&#39; (<span class="op">:</span>)</span></code></pre></div></code></pre>
<p>Now our identifier parser becomes even shorter:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">ident ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>ident <span class="ot">=</span> alpha_ <span class="ot">`thenList`</span> many&#39; (alpha_ <span class="op">&lt;|&gt;</span> digit)</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    alpha_ <span class="ot">=</span> letter <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;_&#39;</span></span></code></pre></div></code></pre>
<p>Now, lets take our combinations a step further.
Say we want to parse a list of comma-separated identifiers,
Here is one way to do that:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">idList ::</span> <span class="dt">Parser</span> [<span class="dt">String</span>]</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>idList <span class="ot">=</span> <span class="kw">do</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  firstId <span class="ot">&lt;-</span> ident</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>  restIds <span class="ot">&lt;-</span> many&#39; (char <span class="ch">&#39;,&#39;</span> <span class="op">&gt;&gt;</span> ident)</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (firstId <span class="op">:</span> restIds)</span></code></pre></div></code></pre>
<p>A token-separated list of items is a commonly occurring pattern in language grammar.
As such, we can abstract away this idea with a <code>sepBy</code> combinator:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Accept a list of sequences forming an `a`, separated by sequences forming a `b`.</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="ot">sepBy ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>p <span class="ot">`sepBy`</span> sep <span class="ot">=</span> <span class="kw">do</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> p</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  xs <span class="ot">&lt;-</span> many&#39; (sep <span class="op">&gt;&gt;</span> p)</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (x <span class="op">:</span> xs)</span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>idList <span class="ot">=</span> ident <span class="ot">`sepBy`</span> char <span class="ch">&#39;,&#39;</span></span></code></pre></div></code></pre>
<p>Now, what if the list of identifiers was enclosed in braces like in an array?
We can define another combinator, <code>bracket</code>, to parse strings enclosed within specific sequences.</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">bracket ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> c <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>bracket open p close <span class="ot">=</span> <span class="kw">do</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> open</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> p</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> close</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> x</span></code></pre></div></code></pre>
<p>Sequencing operators can be used to write <code>bracket</code> in a slightly more elegant manner:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>bracket open p close <span class="ot">=</span> open <span class="op">&gt;&gt;</span> p <span class="op">&lt;*</span> close</span></code></pre></div></code></pre>
<p>Using this, our parser for a list of items can be written as:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>idList <span class="ot">=</span> bracket (char <span class="ch">&#39;[&#39;</span>) ids (char <span class="ch">&#39;]&#39;</span>)</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    ids <span class="ot">=</span> ident <span class="ot">`sepBy`</span> char <span class="ch">&#39;,&#39;</span></span></code></pre></div></code></pre>
<p>Let&#39;s test this implementation in GHCi:</p>
<code><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>*Main&gt; parse idList &quot;[foo,bar,baz]&quot;</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>[([&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;],&quot;&quot;)]</span></code></pre></div></code></pre>
<p>Perfect!</p>
<h2 id="parsing-natural-numbers">Parsing natural numbers</h2>
<p>Since our parsers are polymorphic, we can return a parse result containing an input string&#39;s evaluated value.
Here is a parser that consumes and evaluates the value of a natural number:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Add this to the list of imports:</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="co">-- import Data.Text.Internal.Read (digitToInt)</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">nat ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>nat <span class="ot">=</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  many1 digit <span class="op">&gt;&gt;=</span> eval</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    eval xs <span class="ot">=</span> result <span class="op">$</span> <span class="fu">foldl1</span> op [<span class="fu">digitToInt</span> x <span class="op">|</span> x <span class="ot">&lt;-</span> xs]</span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>    m <span class="ot">`op`</span> n <span class="ot">=</span> <span class="dv">10</span> <span class="op">*</span> m <span class="op">+</span> n</span></code></pre></div></code></pre>
<p>A natural number is one or more decimal digits, which we then fold to produce a base 10 value.
Alternatively, we can use the builtin <code>read</code> to implement <code>nat</code>:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>nat <span class="ot">=</span> <span class="fu">read</span> <span class="op">&lt;$&gt;</span> many1 digit</span></code></pre></div></code></pre>
<h2 id="handling-whitespace">Handling whitespace</h2>
<p>As you may already have noticed, the parsers we&#39;ve written so far aren&#39;t great at dealing with whitespace.</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> parse idList <span class="st">&quot;[a, b, c]&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>[]</span></code></pre></div></code></pre>
<p>Ideally, we should ignore any whitespace before or after tokens.
Generally, it is a tokenizer&#39;s job to handle whitespaces and return a list of tokens that the parser can then use.
However, it is possible to skip a tokenizer completely when using combinators.</p>
<p>We can define a <code>token</code> combinator that takes care of all trailing whitespace:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Add &#39;void&#39; and &#39;isSpace&#39; to import lists.</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="co">-- import Control.Monad (MonadPlus (..), void)</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="co">-- import Data.Char (isDigit, isLower, isUpper, isSpace)</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="ot">spaces ::</span> <span class="dt">Parser</span> ()</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>spaces <span class="ot">=</span> void <span class="op">$</span> many&#39; <span class="op">$</span> sat <span class="fu">isSpace</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a><span class="ot">token ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>token p <span class="ot">=</span> p <span class="op">&lt;*</span> spaces</span></code></pre></div></code></pre>
<p>And a <code>parse&#39;</code> combinator that removes all leading whitespace:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse&#39; ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>parse&#39; p <span class="ot">=</span> spaces <span class="op">&gt;&gt;</span> p</span></code></pre></div></code></pre>
<p>The <code>parse&#39;</code> combinator is applied to the final parser once to ensure there is no leading whitespace.
The <code>token</code> combinator consumes all trailing whitespace,
hence ensuring there is no leading whitespace left for the subsequent parsers.</p>
<p>We can now write parsers that disregard whitespace:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">identifier ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>identifier <span class="ot">=</span> token ident</span></code></pre></div></code></pre>
<p>At this point, we have atomic parsers that can be plugged in several places.
One such place can be an arithmetic expression evaluator:</p>
<h2 id="an-expression-parser">An expression parser</h2>
<p>Finally, to demonstrate the usefulness of combinators we have defined so far, we build a basic arithmetic expression parser.
We will support the binary <code>+</code> and <code>-</code> operators, parenthesized expressions and integer literals.
By the end, we will have an <code>eval</code> function that can evaluate expressions like so:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> eval <span class="st">&quot;1 + 2 - 3 - 4 + 10&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span></span></code></pre></div></code></pre>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="co">-- consume a character and discard all trailing whitespace</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="ot">charToken ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>charToken <span class="ot">=</span> token <span class="op">&lt;$&gt;</span> char</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="co">-- an ADT representing a parse tree for expressions</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Sub</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Par</span> <span class="dt">Expr</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">Lit</span> <span class="dt">Int</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>          <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a></span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a><span class="ot">eval&#39; ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a>eval&#39; (<span class="dt">Add</span> a b) <span class="ot">=</span> eval&#39; a <span class="op">+</span> eval&#39; b</span>
<span id="15"><a href="#15" aria-hidden="true" tabindex="-1"></a>eval&#39; (<span class="dt">Sub</span> a b) <span class="ot">=</span> eval&#39; a <span class="op">-</span> eval&#39; b</span>
<span id="16"><a href="#16" aria-hidden="true" tabindex="-1"></a>eval&#39; (<span class="dt">Par</span> a)   <span class="ot">=</span> eval&#39; a</span>
<span id="17"><a href="#17" aria-hidden="true" tabindex="-1"></a>eval&#39; (<span class="dt">Lit</span> a)   <span class="ot">=</span> a</span>
<span id="18"><a href="#18" aria-hidden="true" tabindex="-1"></a></span>
<span id="19"><a href="#19" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="20"><a href="#20" aria-hidden="true" tabindex="-1"></a>eval <span class="ot">=</span>  <span class="fu">fst</span> <span class="op">.</span> Bifunctor.first eval&#39; <span class="op">.</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> parse expr</span>
<span id="21"><a href="#21" aria-hidden="true" tabindex="-1"></a></span>
<span id="22"><a href="#22" aria-hidden="true" tabindex="-1"></a><span class="co">-- Our expression parser expects a string of the following grammar:</span></span>
<span id="23"><a href="#23" aria-hidden="true" tabindex="-1"></a><span class="co">-- expr ::= term (op term)*</span></span>
<span id="24"><a href="#24" aria-hidden="true" tabindex="-1"></a><span class="co">-- op ::= &#39;+&#39; | &#39;-&#39;</span></span>
<span id="25"><a href="#25" aria-hidden="true" tabindex="-1"></a><span class="co">-- term ::= int | &#39;(&#39; expr &#39;)&#39;</span></span>
<span id="26"><a href="#26" aria-hidden="true" tabindex="-1"></a><span class="co">-- int ::= [0-9]*</span></span>
<span id="27"><a href="#27" aria-hidden="true" tabindex="-1"></a></span>
<span id="28"><a href="#28" aria-hidden="true" tabindex="-1"></a><span class="co">-- The `expr` parser first consumes an atomic term - &lt;X&gt;, then it</span></span>
<span id="29"><a href="#29" aria-hidden="true" tabindex="-1"></a><span class="co">-- consumes a series of &quot;&lt;op&gt; &lt;operand&gt;&quot;s and packs them into tuples like ((+), 2)</span></span>
<span id="30"><a href="#30" aria-hidden="true" tabindex="-1"></a><span class="co">-- We then fold the list of tuples using &lt;X&gt; as the initial value to produce the result.</span></span>
<span id="31"><a href="#31" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="32"><a href="#32" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="33"><a href="#33" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> term</span>
<span id="34"><a href="#34" aria-hidden="true" tabindex="-1"></a>  rest <span class="ot">&lt;-</span> many&#39; parseRest</span>
<span id="35"><a href="#35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span></span>
<span id="36"><a href="#36" aria-hidden="true" tabindex="-1"></a>    <span class="fu">foldl</span> (\x (op, y) <span class="ot">-&gt;</span> x <span class="ot">`op`</span> y) x rest</span>
<span id="37"><a href="#37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="38"><a href="#38" aria-hidden="true" tabindex="-1"></a>    parseRest <span class="ot">=</span> <span class="kw">do</span></span>
<span id="39"><a href="#39" aria-hidden="true" tabindex="-1"></a>      f <span class="ot">&lt;-</span> op</span>
<span id="40"><a href="#40" aria-hidden="true" tabindex="-1"></a>      y <span class="ot">&lt;-</span> term</span>
<span id="41"><a href="#41" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (f, y)</span>
<span id="42"><a href="#42" aria-hidden="true" tabindex="-1"></a></span>
<span id="43"><a href="#43" aria-hidden="true" tabindex="-1"></a><span class="co">-- term := int | parens</span></span>
<span id="44"><a href="#44" aria-hidden="true" tabindex="-1"></a><span class="ot">term ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="45"><a href="#45" aria-hidden="true" tabindex="-1"></a>term <span class="ot">=</span> int <span class="op">&lt;|&gt;</span> parens</span>
<span id="46"><a href="#46" aria-hidden="true" tabindex="-1"></a></span>
<span id="47"><a href="#47" aria-hidden="true" tabindex="-1"></a><span class="co">-- parens := &#39;(&#39; expr &#39;)&#39;</span></span>
<span id="48"><a href="#48" aria-hidden="true" tabindex="-1"></a><span class="ot">parens ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="49"><a href="#49" aria-hidden="true" tabindex="-1"></a>parens <span class="ot">=</span> bracket (char <span class="ch">&#39;(&#39;</span>) expr (char <span class="ch">&#39;)&#39;</span>)</span>
<span id="50"><a href="#50" aria-hidden="true" tabindex="-1"></a></span>
<span id="51"><a href="#51" aria-hidden="true" tabindex="-1"></a><span class="co">-- int := [0-9]*</span></span>
<span id="52"><a href="#52" aria-hidden="true" tabindex="-1"></a><span class="ot">int ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="53"><a href="#53" aria-hidden="true" tabindex="-1"></a>int <span class="ot">=</span> <span class="dt">Lit</span> <span class="op">&lt;$&gt;</span> token nat</span>
<span id="54"><a href="#54" aria-hidden="true" tabindex="-1"></a></span>
<span id="55"><a href="#55" aria-hidden="true" tabindex="-1"></a><span class="co">-- op := &#39;+&#39; | &#39;-&#39;</span></span>
<span id="56"><a href="#56" aria-hidden="true" tabindex="-1"></a><span class="ot">op ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>)</span>
<span id="57"><a href="#57" aria-hidden="true" tabindex="-1"></a>op <span class="ot">=</span> makeOp <span class="ch">&#39;+&#39;</span> <span class="dt">Add</span> <span class="op">&lt;|&gt;</span> makeOp <span class="ch">&#39;-&#39;</span> <span class="dt">Sub</span></span>
<span id="58"><a href="#58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> makeOp x f <span class="ot">=</span> charToken x <span class="op">&gt;&gt;</span> <span class="fu">return</span> f</span></code></pre></div></code></pre>
<p>Spin up GHCi, and there we have it:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> eval <span class="st">&quot;1 + 2 - (3 - 1)&quot;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> eval <span class="st">&quot;1 + 2 + 3&quot;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span></span></code></pre></div></code></pre>
<p>Our parser is decent, but it can be refactored a little further.
An expression is a list of parenthesized expressions and integer literals separated by <code>+</code> or <code>-</code>.</p>
<p>As it turns out, parsing a list of token delimited items is a common pattern captured by the <code>chainl1</code> combinator:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">chainl1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>p <span class="ot">`chainl1`</span> op <span class="ot">=</span> <span class="kw">do</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  first <span class="ot">&lt;-</span> p</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>  rest <span class="ot">&lt;-</span> many&#39; <span class="op">$</span> <span class="kw">do</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    f    <span class="ot">&lt;-</span> op</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    term <span class="ot">&lt;-</span> p</span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (f, term)</span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">foldl</span> (\x (f, y) <span class="ot">-&gt;</span> f x y) first rest</span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> term <span class="ot">`chainl1`</span> op</span></code></pre></div></code></pre>
<p>And with that, we have a monadic expression parser composed of several tiny and modular parsers.
As an exercise, you can extend this parser and add more operators such as multiplication, division, and log.</p>
<h2 id="further-reading">Further reading</h2>
<p>There are already several parser combinator libraries for many languages, as you may have guessed.
<a href="https://hackage.haskell.org/package/parsec">Parsec</a> in particular, is the most commonly used one among Haskell programmers.
Here are more resources for you to chew on:</p>
<ol>
<li><a href="https://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf">Monadic Parser Combinators</a>
</li>
<li><a href="https://www.cs.nott.ac.uk/~pszgmh/pearl.pdf">Functional Pearls - Monadic Parsing in Haskell</a>
</li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf">Microsoft Research - Direct style monadic parser combinators for the real world</a>
</li>
</ol>
<p>The first two should feel very familiar if you&#39;ve followed the post so far.
The 3rd is a paper that attempts to provide a better alternative technique for parsing using monads.</p>
<p>At this point, parser combinators have become another tool in your functional programming arsenal.
Go forth and write some killer parsers!</p>
<h2 id="backmatter">Backmatter</h2>
<ol>
<li>
<p>In most implementations, the parse result is a functor that can store an error message in case the parser fails.</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="ot">=</span> <span class="dt">Parser</span> {<span class="ot"> parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ParseResult</span> a }</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ParesResult</span> a <span class="ot">=</span> <span class="dt">Either</span> <span class="dt">ParseError</span> a</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ParseError</span> <span class="ot">=</span> <span class="dt">String</span></span></code></pre></div></code></pre>
</li>
<li>
<p>In order to instantiate Parser as a Monad in Haskell, we also have to make it an instance of <code>Functor</code> and <code>Applicative</code>:</p>
</li>
</ol>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f p <span class="ot">=</span> <span class="dt">Parser</span> (<span class="fu">fmap</span> (Bifunctor.first f) <span class="op">.</span> parse p)</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> result</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>  p1 <span class="op">&lt;*&gt;</span> p2 <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \inp <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>      (f, inp&#39;) <span class="ot">&lt;-</span> parse p1 inp</span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>      (a, inp&#39;&#39;) <span class="ot">&lt;-</span> parse p2 inp&#39;</span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (f a, inp&#39;&#39;)</span></code></pre></div></code></pre>


			<script src="https://giscus.app/client.js" data-repo="srijan-paul/srijan-paul.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMTY0MTg0NTk=" data-category="Announcements" data-category-id="DIC_kwDOEtwpm84Cdokt" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" defer>
			</script>
		</div>
  </body>
</html>
