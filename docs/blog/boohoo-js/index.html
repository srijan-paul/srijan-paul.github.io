<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/common.css">
    <link rel="stylesheet" href="/css/post.css">
    <link rel="stylesheet" href="/css/theme.css">
    <meta name="description" content="JavaScript may be terrible, but it&#39;s not as bad as you think">
    

    <title>BoOHoO JaVaScRiPT!!</title>
  </head>

  <body>
    <div class="main">
      <div class="nav">
        <div class="nav-left">
          <a id="home-link" href="/">injuly.in</a>
        </div>

        <div class="nav-right">
          <a href="/" class="nav-link">index</a>
          <a href="/about" class="nav-link">about</a>
          <a href="/blog" class="nav-link">blog</a>
          <a href="/current" class="nav-link">current</a>
        </div>
      </div>

      <hr style="height:1px;border:none;color:#333;background-color:#333;">

      <div class="leader">
        <h2> BoOHoO JaVaScRiPT!! </h2>
        <div class="post-date"></div>
        <span class="tags" id="tags">
        </span>
      </div>
      <code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="fl">0.1</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">==</span> <span class="fl">0.3</span>       <span class="co">// false</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="kw">NaN</span> <span class="op">==</span> <span class="kw">NaN</span>             <span class="co">// false</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="kw">typeof</span> <span class="kw">NaN</span>             <span class="co">// &quot;number&quot;</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="kw">true</span> <span class="op">==</span> <span class="dv">1</span>              <span class="co">// true</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">31</span>]<span class="op">.</span><span class="fu">sort</span>()      <span class="co">// [ 31, 4, 5 ]</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="bu">Math</span><span class="op">.</span><span class="fu">max</span>()             <span class="co">// -Infinity</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] <span class="op">==</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] <span class="co">// false</span></span></code></pre></div></code></pre>
<p>Moreover:</p>
<ol>
<li>JavaScript is slow.
</li>
<li>Untyped and extremely unsafe.
</li>
<li>Single threaded.
</li>
</ol>
<p>If you&#39;re anything but a very new programmer, the above might come off as obvious to you, and you might be better of skipping half of this post! However, it really is true that the above are some of the most &quot;meme&quot;-d takes on JavaScript. Type &quot;JavaScript bad meme&quot; into your search engine of choice to convince yourself, that&#39;s how I got to the bunch above.</p>
<p>&quot;JavaScript bad because <code>0.1 + 0.2 != 0.3</code>&quot; is tech-twitter&#39;s favorite game to play on weekends!</p>
<p>Before we move on, Let&#39;s establish this:</p>
<blockquote>
<p>I want to pick on JavaScript&#39;s <strong>design</strong>, not it&#39;s <strong>ecosystem</strong>.</p>
</blockquote>
<h2 id="playing-the-devils-advocate">Playing the devil&#39;s advocate</h2>
<p>First, let&#39;s briefly dissect the expressions one by one, starting with the most common:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="fl">0.1</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">==</span> <span class="fl">0.3</span><span class="op">;</span> <span class="co">// false</span></span></code></pre></div></code></pre>
<p>This is not JavaScript&#39;s fault, but a by-product of how computers represent floating point numbers.
You see, we can&#39;t have infinite precision decimals within finite space, so we make a trade-off. We store all floating point numbers in 64-bits of space, and loose some precision in the process. This is standardized by the <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 64 bit floating point representation</a>. The Wikipedia article does a better job of explaining it than I ever could, so I refer you to that in case you want to know more.</p>
<p>Most other languages do the same thing. C, Java, C++, Lua, Python and friends.
Note however that some do not, <a href="https://www.raku.org/">Raku</a> (also called Perl-6 by some) for example, correctly evaluates <code>0.1 + 0.2</code> to <code>0.3</code>.
Magic? Nope, just a different representation written in software. Instead of using IEEE floats, Raku uses rational numbers of the form <code>p/q</code> where <code>p</code> and <code>q</code> share no common factors barring 1.</p>
<p>Why don&#39;t all languages do what Raku does?
This has some trade-offs, speed is the very obvious first candidate, but also space. Now we have to store 2 numbers, <code>p</code> and <code>q</code>. This not only means twice the space, but the number may no longer fit in CPU registers.</p>
<p>Next up, we have:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">NaN</span> <span class="op">==</span> <span class="kw">NaN</span><span class="op">;</span> <span class="co">// false</span></span></code></pre></div></code></pre>
<p>This one is also simple, The aforementioned IEEE double precision floating point spec simply states that <code>NaN</code> must never be equal to another <code>NaN</code>. To my knowledge, this is mostly to immediately raise alarms instead of quietly passing through conditions of <code>if</code> statements and such.</p>
<p>Moving on...</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">typeof</span> <span class="kw">NaN</span><span class="op">;</span> <span class="co">// number</span></span></code></pre></div></code></pre>
<p><code>NaN</code> literally means &quot;not a number&quot;, so why does JavaScript tell me otherwise? This could have been handled differently by having a separate <code>&quot;NaN&quot;</code> type. However it does make sense when you think about it this way, the <code>NaN</code> value always appears in places where you would expect numbers. <code>Math.sqrt(-1)</code> for example.</p>
<p>And now:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">true</span> <span class="op">==</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// true</span></span></code></pre></div></code></pre>
<p>This is debatable. Python, Ruby and C++ do what JavaScript here does, Lua however disagrees. Java rebels and throws a type error at compile time. If you ask me, all these approaches make sense. In duck typed languages, we&#39;re seldom concerned with an actual boolean value, and really care about <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthy-ness</a>.</p>
<p>In case of JavaScript, if we complain about the above, then why not maintain the same energy for this:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="dv">0</span>) {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* stuff */</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></code></pre>
<p>Why is it okay to substitute <code>0</code> (or <code>&#39;&#39;</code>) for <code>false</code> but not <code>true</code> for <code>1</code>?</p>
<p>The <code>==</code> operator compares <strong>truthiness</strong> of values. i.e it makes a judgement based on a <strong>property</strong> of it&#39;s operands, and not the values themselves. Take a look:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// true</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span> <span class="co">// true</span></span></code></pre></div></code></pre>
<p>Note however that it&#39;s overloaded to act differently for numbers and strings (and this weird polymorphism is a fair critique, which we&#39;ll address).
If you want strict value comparison, use <code>==</code>&#39;s sister <code>===</code> instead.</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;&quot;</span> <span class="op">===</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// false</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">===</span> <span class="st">&quot;&quot;</span><span class="op">;</span> <span class="co">// false</span></span></code></pre></div></code></pre>
<p>Up next:</p>
<code class="language-java"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span><span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">31</span><span class="op">].</span><span class="fu">sort</span><span class="op">()</span> <span class="co">// [ 31, 4, 5 ]</span></span></code></pre></div></code></pre>
<p>Now this, is questionable API design choice. I completely agree with that. However, it doesn&#39;t tie into the semantics of JavaScript as a language in any way. In the same spirit, one could pick bones with C++&#39;s poorly named standard library entities. (<code>std::empty</code> instead of <code>std::is_empty</code>).</p>
<p>To do a number comparison-based sort, you&#39;d have to call it like so:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">31</span>]<span class="op">.</span><span class="fu">sort</span>((a<span class="op">,</span> b) <span class="kw">=&gt;</span> a <span class="op">-</span> b)<span class="op">;</span> <span class="co">// [4, 5, 31]</span></span></code></pre></div></code></pre>
<p>Just to be clear, I believe this is a completely fair and valid criticism, just not of the language, but it&#39;s standard library.</p>
<p>Following up with:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="bu">Math</span><span class="op">.</span><span class="fu">max</span>()<span class="op">;</span> <span class="co">// -Infinity</span></span></code></pre></div></code></pre>
<p><code>Math.max</code> is a variadic function, meaning you can call it with 1, 2, 3 or 0 arguments. When called with 0 arguments, it returns <code>-Infinity</code>. Why? Because maximum of an empty set is negative infinity.</p>
<p>Why not throw an arity error on 0 arguments you ask? Because there are cases where the number of arguments isn&#39;t known at compile time. For example, calling it with the spread operator like <code>Math.max(...myArgs)</code>. In fact, try implementing <code>Math.max</code> yourself, how would you do it?</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="bu">Math</span><span class="op">.</span><span class="fu">max</span> <span class="op">=</span> (args<span class="op">...</span>) <span class="kw">=&gt;</span> {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> maxSoFar <span class="op">=</span> <span class="co">/* what? */</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    args<span class="op">.</span><span class="fu">forEach</span>(arg <span class="kw">=&gt;</span> {</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> (arg <span class="op">&gt;</span> maxSoFar) maxSoFar <span class="op">=</span> arg<span class="op">;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxSoFar<span class="op">;</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></code></pre>
<p>What should <code>maxSoFar</code> be initialized with? What is that one value which is guaranteed to be less than anything in <code>args</code>? Why <code>-Infinity</code> of course! Note that we can&#39;t initialize it with <code>args[0]</code> here because the index may be out of bounds, when <code>args</code> is empty. Another approach could be:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="bu">Math</span><span class="op">.</span><span class="fu">max</span> <span class="op">=</span> (args<span class="op">...</span>) <span class="kw">=&gt;</span> {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> (args<span class="op">.</span><span class="at">length</span> <span class="op">&lt;</span> <span class="dv">1</span>) <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&quot;Expected at least 1 argument&quot;</span>)<span class="op">;</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>   <span class="co">// ...</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></code></pre>
<p>This is a completely valid approach as well, just different from what JavaScript does. I hope given the perspective above, you can see why neither of them are better or worse than the other. Neither is void of reason, they just have different conventions.</p>
<p>Finally,</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] <span class="op">==</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span></code></pre></div></code></pre>
<p>This is the simplest, most trivial snippet. It&#39;s just heap allocation. The two arrays are different objects living at different places in memory. When you modify one, the other doesn&#39;t change. If JavaScript had operator overloading, one could perhaps override <code>==</code> for <code>Array.prototype</code> and achieve element-by-element comparison? Who knows.</p>
<p>Now to tackle the rest:</p>
<h2 id="javascript-is-slow">JavaScript is slow.</h2>
<p>Programming languages do not have performance characteristics.
Their implementations do.
Python isn&#39;t inherently a slow language, though its interpreter(CPython) might be.
Using a different implementation (Numba, PyPy, Cinder, etc.) will always react differently to benchmarks.</p>
<p>That said, the design of a language can heavily influence its general performance, across implementations.
Languages that exhibit highly dynamic behaviour are difficult to optimize, and therefore tend to be slower than their compiled friends.</p>
<p>Some of the most vital JavaScript engines today, V8, JSC, Hermes, and SpiderMonkey are extremely performant, optimizing beasts. They&#39;re JIT compilers, the precise inner workings of which warrant an essay of their own.</p>
<p>Taking a look at some benchmarks from the <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">computer language benchmark games</a> site, it would appear that Node.js (which embeds V8) is actually not bad at all, even beating some implementations of Java, Haskell, and C++ (!?).</p>
<p>Of course, Benchmarks do not represent real world programs.
You don&#39;t use JavaScript to crunch high volumes of data, or do automatic differentiation (If you do, I urge you to reconsider).
You use JavaScript to color buttons on a webpage.</p>
<h2 id="javascript-is-untyped-and-unsafe">JavaScript is untyped and unsafe.</h2>
<p>No. JavaScript is <strong>dynamically checked</strong> and <strong>safe</strong>.
Take this excerpt out of Pierce&#39;s book, <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">Types and programming languages</a>:</p>
<blockquote>
<p>Terms like &quot;dynamically typed&quot; are arguably misnomers and should probably be replaced by &quot;dynamically checked,&quot; but the usage is standard.</p>
</blockquote>
<p><strong>Dynamically checked:</strong> Variables and symbols do <strong>not</strong> have types. The types are bound to <strong>values</strong> instead.</p>
<p>Let&#39;s try with an example. The number <code>100</code>, has a type of &quot;number&quot; at runtime. However in this statement:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span></code></pre></div></code></pre>
<p>The <strong>symbol</strong> &quot;x&quot; and in it&#39;s semantic definition, does not have a type. But it&#39;s still not wrong to say <em>&quot;the type of &#39;x&#39; is <code>number</code>&quot;</em>. Why? Because when <code>x</code> is evaluated by the runtime, as a <strong>value</strong>, it does have a type (which can be seen by evaluating <code>typeof x</code>).</p>
<p>However the <strong>name</strong> &quot;x&quot; is void of any type. So we can do <code>x = &#39;xyz&#39;</code> and the interpreter will happily run it.</p>
<p>The key is to understand the difference between the <strong>name</strong> &#39;&#39;x&quot; which can be bound to any value, and the <strong>value</strong> &quot;x&quot;, which always evaluates to whichever value the name is bound to at the time of evaluation.</p>
<p><strong>Safety</strong>: The most commonly accepted definition of safety is:
<em>A language where every code snippet always is well-defined by the standard.</em></p>
<p>And this is indeed true of JavaScript. If you don&#39;t like that thought, pause for a second and try to come up with a JavaScript code snippet that is <strong>undefined</strong> under the ECMAScript spec. You&#39;ll find that none exist. It may error out, or produce wonky output, but the behaviour is <strong>defined</strong>, and will be the same for every standard-compliant JavaScript implementation.</p>
<p>In fact, C++ is <strong>less safe</strong> than JavaScript, despite being statically typed (which makes sense, because typing and safety are orthogonal). For example, the following C++ code does not have any defined behaviour:</p>
<code class="language-cpp"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> IntOrPtr <span class="op">{</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> integer<span class="op">;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> ptr<span class="op">;</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>  IntOrPtr u <span class="op">=</span> <span class="op">{</span> <span class="op">.</span>ptr <span class="op">=</span> <span class="st">&quot;some string&quot;</span> <span class="op">};</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> u<span class="op">.</span>integer <span class="op">&lt;&lt;</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">;</span> <span class="co">// &lt;--- Whoops!</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></code></pre>
<p>Accessing the uninitialized field of a union is undefined behavior, and may have different behavior on different compilers, hardware, OS, or different runs of the same executable.</p>
<table>
<thead>
<tr>
<th></th>
<th>Safe</th>
<th>Unsafe</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Dynamic checking</strong></td>
<td>Easy to write erroneous code, but easier to debug due to well defined runtime behavior and inspection capability.</td>
<td>Don&#39;t know of any such languages except hobby projects.</td>
</tr>
<tr>
<td><strong>Static checking</strong></td>
<td>Best of both worlds. Most languages in this bucket are either functional, or r***-like.</td>
<td>Easier to write correct programs, but harder to debug as there are no types and bounds at runtime.</td>
</tr>
</tbody>
</table>
<p>There is always a tradeoff.
If you miss having compile time type checking when writing JS, maybe checkout Typescript/Purescript?</p>
<h3 id="javascript-is-single-threaded-hence-bad">JavaScript is single threaded, hence bad.</h3>
<p>I don&#39;t disagree with this one.</p>
<p>Thankfully V8 (and <del>NodeJS</del> libuv) are designed well enough that this problem is easily circumvented with asynchronous code.</p>
<p>Some languages have built-in multithreading support,
like atomic data types, or operators that spawn threads/processes.</p>
<h3 id="not-all-roses">Not all roses.</h3>
<p>Ok, now that I&#39;m done playing the devil&#39;s advocate,
I do have my own fair share of complaints.</p>
<ol>
<li>
<p>Starting off on an easier foot, the <code>var</code> keyword. ECMA&#39;s unwillingness to forsake backwards compatibility has led to some very annoying legacy cruft in JS that just won&#39;t go away. <strong>Function scope</strong> is one of those.</p>
</li>
<li>
<p><strong>Too much implicit type-coercion</strong>. The type system is incorrigibly broken. Everything can coerce into Everything, and the runtime will jump through all kinds of hoops before throwing an error.</p>
</li>
<li>
<p><strong>Wonky whitespace sensitivity.</strong>
JavaScript looks like it&#39;s not white-space sensitive at first glance. Catch this:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">124</span> <span class="co">// ok</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="dv">100</span> <span class="co">// ok</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">124</span> d <span class="op">=</span> <span class="dv">214</span> <span class="co">// NOT OK</span></span></code></pre></div></code></pre>
<p>That&#39;s right, it isn&#39;t really white-space sensitive at all. I wish the language had simpler rules regarding this, but that&#39;s unfortunately not the case. So we rely on linters to warn us. (This ties into the next point).</p>
</li>
<li>
<p><strong>Automatic semi-colon insertion</strong>. What you&#39;re seeing above is really an effect of <a href="https://262.ecma-international.org/7.0/#sec-rules-of-automatic-semicolon-insertion">this</a> annoying ECMA ruleset. So behold:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ten</span>() {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">10</span><span class="op">;</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="fu">ten</span>())<span class="op">;</span> <span class="co">// undefined</span></span></code></pre></div></code></pre>
<p>This not very obvious when your functions are deeply nested and the expression is big, like:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">foo</span>() {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="op">..</span>) {</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="op">..</span>) {</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (<span class="op">...</span>) {</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (<span class="op">...</span>) {</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// not doing what you think it&#39;s doing</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>                    	GetFooFactory<span class="op">.</span><span class="fu">MakeFoo</span>(<span class="fu">MakeBar</span>(<span class="fu">Baz</span>(Pop<span class="op">,</span> Bop)))</span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>                }</span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></code></pre>
</li>
<li>
<p><strong>Contextual keywords</strong>. <code>async</code>, <code>await</code> and even <code>let</code> are keywords under some contexts and identifiers under others. This leads to some funny possibilities like <code>var let = 100</code>. Although not inherently bad, I still dislike them personally because of it&#39;s inconsistent nature.</p>
</li>
<li>
<p><strong>Unused reserved words</strong>. <code>enum</code>, <code>private</code>, <code>public</code> are reserved words that you cannot use. But they don&#39;t bring any features to the language. ECMA just <em>might</em> one day add private members or enums and so they reserved these words. I see this as a good strategy, but why not do one thing? If you have contextual keywords, then make these keywords contextual too instead of &quot;pre-reserving&quot; them and making other future keywords contextual. That said, I see this as a reasonable approach. Although I don&#39;t quite understand why implementing enums is taking so long :p</p>
</li>
<li>
<p><strong>Hoisting</strong>. Not a big deal, but not WSYIWYG. I like my scripting languages WSYIWYG, thank you.</p>
</li>
</ol>
<p>There&#39;s some other smaller problems like no native integers etc. But I can live with those. In contrast, I <em>have</em> to live with the above.</p>
<h2 id="what-is-tomorrow-like">What is tomorrow like?</h2>
<p>JS will always have to be backwards compatible, so a lot of these quirks are unfortunately here to stay.</p>
<p>On the brighter side, newer additions to JavaScript have been fairly nice!
Besides, we are still in the early dawn of programming languages.
We might one day see a language that is both popularly used and popularly liked.</p>
<blockquote>
<p><em>&quot;There are only two kinds of languages: the ones people complain about and the ones nobody uses.&quot;</em> &gt; <strong><div style="text-align: right">- Bjarne Stroustrup </div></strong></p>
</blockquote>
<h2 id="faq">FAQ</h2>
<ul>
<li><strong>So do you like JS or not?</strong> No comments.
</li>
<li><strong>Why did you feel the need to write this blog post?</strong> I have time, and no job. Go figure.
</li>
<li><strong>Why is there an FAQ section when clearly nobody is reading this ever?</strong> Rude :(
</li>
<li><strong>Show me more wonky JavaScript.</strong> Go to <a href="https://wtfjs.com/">wtfjs</a> and knock yourself out.
</li>
<li><strong>JavaScript done right?</strong> I have searched for ages, but couldn&#39;t find anything better than PureScript or Dart (when transpiled). it is extremely difficult for scripting languages to enter browsers, unless the transpile to the unholy devilspawn.
</li>
<li><strong>Why are there references to Dante&#39;s inferno?</strong> That is the closest entertaining piece of literature in my recent memory and I don&#39;t want a completely bland wall of text.
</li>
</ul>



      <div class="footer">
        <hr>
        Questions, suggestions or comments? <br />
        Shoot me an <a href="mailto:srijannr1@gmail.com">email</a>, or <a href="https://twitter.com/_injuly">tweet@me</a>.
      </div>
    </div>

    <script src="/util.js"></script>
    <script>
      const tagsDiv = document.getElementById("tags");
      // the [foo][0] is a hack for when `foo` evaluates to nothing in mustache
      const tags = [["javascript","programming-languages","post"]][0]; 
      tags.forEach(tag => {
              const li = document.createElement("a")
              li.classList.add("tag")
              li.href = `/posts/index.html?tag=${tag}`
              li.innerHTML = tag
              tagsDiv.appendChild(li)
            });

      const dateElement = document.querySelector(".post-date");
      dateElement.innerText = dateToString(new Date("2021-07-18"), true);
    </script>
  </body>
</html>

