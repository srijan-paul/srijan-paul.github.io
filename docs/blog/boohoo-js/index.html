<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
    <meta name="description" content="JavaScript may be terrible, but it&#39;s not as bad as you think"></meta>
    <meta property="og:title" content="BoOHoO JaVaScRiPT!!"></meta>
    <meta property="twitter:title" content="BoOHoO JaVaScRiPT!!"></meta>
    <meta property="twitter:description" content></meta>

     
    <meta property="og:image" content></meta>
		<meta name="twitter:image" content>
    

    <meta property="og:site_name" content="InJuly"></meta>

    <link rel="stylesheet" href="/assets/css/common.css">
    <link rel="stylesheet" href="/assets/css/post.css">
    <link rel="stylesheet" href="/assets/css/theme.css">
    

    <script data-goatcounter="https://injuly.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>


    <title>BoOHoO JaVaScRiPT!!</title>
  </head>

  <body>
    <div class="main">
      <div class="nav">
        <div class="nav-left">
          <a id="home-link" href="/">injuly</a>
        </div>

        <div class="nav-right">
          <a href="/" class="nav-link">index</a>
          <a href="/about" class="nav-link">about</a>
          <a href="/blog" class="nav-link">blog</a>
          <a href="/now" class="nav-link">now</a>
        </div>
      </div>

      <hr>

      <div class="leader">
        <h2> BoOHoO JaVaScRiPT!! </h2>
        <div class="post-date"></div>
        <span class="tags" id="tags">
            <a class="tag" href="/posts/index.html?tag=javascript">javascript</a>
            <a class="tag" href="/posts/index.html?tag=programming-languages">programming-languages</a>
            <a class="tag" href="/posts/index.html?tag=post">post</a>
        </span>
      </div>
      <p>Here&#39;s a few lines of JavaScript code that, apparently, make it a bad programming language:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="fl">0.1</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">==</span> <span class="fl">0.3</span>       <span class="co">// false</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="kw">NaN</span> <span class="op">==</span> <span class="kw">NaN</span>             <span class="co">// false</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="kw">typeof</span> <span class="kw">NaN</span>             <span class="co">// &quot;number&quot;</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="kw">true</span> <span class="op">==</span> <span class="dv">1</span>              <span class="co">// true</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">31</span>]<span class="op">.</span><span class="fu">sort</span>()      <span class="co">// [ 31, 4, 5 ]</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="bu">Math</span><span class="op">.</span><span class="fu">max</span>()             <span class="co">// -Infinity</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] <span class="op">==</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] <span class="co">// false</span></span></code></pre></div></code></pre>
<p>Or at least that&#39;s what today&#39;s twitter trending page told me (yes, JavaScript was trending on twitter, probably because of Hacktoberfest).
Unconvinced? Look up &quot;JavaScript bad meme&quot; in the search bar and see for yourself.</p>
<h2 id="playing-the-devils-advocate">Playing the devil&#39;s advocate</h2>
<p>First, let&#39;s briefly dissect the expressions one by one, starting with the most common:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="fl">0.1</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">==</span> <span class="fl">0.3</span><span class="op">;</span> <span class="co">// false</span></span></code></pre></div></code></pre>
<p>This is not JavaScript&#39;s fault, but a by-product of how computers represent floating point numbers.
You can&#39;t have infinite precision decimals within finite space, so we make a trade-off. We store all floating point numbers in 64-bits of space, and loose some precision in the process. This is standardized by the <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 64 bit floating point representation</a>. The Wikipedia article does a better job of explaining it than I ever could.</p>
<p>Most other languages do the same thing. C, Java, C++, Lua, Python, you name it.
Note however that some do not, <a href="https://www.raku.org/">Raku</a>  for example, correctly evaluates <code>0.1 + 0.2</code> to <code>0.3</code>. Instead of using IEEE floats, Raku uses rational numbers of the form <code>p/q</code> where <code>p</code> and <code>q</code> share no common factors barring 1.</p>
<p>So why don&#39;t all languages do what Raku does?
For one, you now store two numbers instead of one to represent a single float.
Secondly, most CPUs have hardware circuits that perform arithmetic on IEEE floats.
In a sufficiently CPU intensive application, losing out on hardware accelerated arithmetic can slow things down significantly.</p>
<p>Next up, we have:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">NaN</span> <span class="op">==</span> <span class="kw">NaN</span><span class="op">;</span> <span class="co">// false</span></span></code></pre></div></code></pre>
<p>This one is also simple, The aforementioned IEEE double precision floating point spec blithely states that <code>NaN</code> must never be equal to another <code>NaN</code>. That way, if you have two <code>NaN</code>s as the result of logic errors in your program, they won&#39;t pass any equality checks by mistake.</p>
<p>Moving on...</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">typeof</span> <span class="kw">NaN</span><span class="op">;</span> <span class="co">// number</span></span></code></pre></div></code></pre>
<p><code>NaN</code> literally means &quot;not a number&quot;, so why does JavaScript tell me otherwise? This could have been handled differently by having a separate <code>NaN</code> type. However it makes sense when you think about it this way: the <code>NaN</code> value always appears in places where you would expect numbers, as the result of numeric operations, <code>Math.sqrt(-1)</code> for example.</p>
<p>Most other languages also represent <code>NaN</code> in their floating point data types.</p>
<p>And now:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">true</span> <span class="op">==</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// true</span></span></code></pre></div></code></pre>
<p>This is debatable. Python, Ruby and C++ do what JavaScript here does, Lua however disagrees. Java croaks and throws a type error at compile time. If you ask me, all these approaches make sense. In duck typed languages, we&#39;re seldom concerned with an actual boolean value, and really care about its <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthy-ness</a>.</p>
<p>The following snippet passes in both C (and C++, sometimes with a compiler warning) and JavaScript:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="dv">0</span>) {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* stuff */</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></code></pre>
<p>The <code>==</code> operator compares <strong>truthiness</strong> of values. i.e it makes a judgement based on a <strong>property</strong> of it&#39;s operands, and not the values themselves. Consider:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// true</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span> <span class="co">// true</span></span></code></pre></div></code></pre>
<p>Note however that it&#39;s overloaded to act differently for numbers and strings (and this behaviour <em>is</em> bad design).
If you want strict value comparison, use <code>==</code>&#39;s sister <code>===</code> instead.</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;&quot;</span> <span class="op">===</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// false</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">===</span> <span class="st">&quot;&quot;</span><span class="op">;</span> <span class="co">// false</span></span></code></pre></div></code></pre>
<p>Up next:</p>
<code class="language-java"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span><span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">31</span><span class="op">].</span><span class="fu">sort</span><span class="op">()</span> <span class="co">// [ 31, 4, 5 ]</span></span></code></pre></div></code></pre>
<p>This questionable API design.
I don&#39;t have much to say about this, except that I&#39;d prefer <code>sort</code> either default to numeric sorting, or mandate the comparator argument.</p>
<p>To do a number comparison-based sort, you&#39;d have to call it like so:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">31</span>]<span class="op">.</span><span class="fu">sort</span>((a<span class="op">,</span> b) <span class="kw">=&gt;</span> a <span class="op">-</span> b)<span class="op">;</span> <span class="co">// [4, 5, 31]</span></span></code></pre></div></code></pre>
<p>Now, <code>Math.max</code>:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="bu">Math</span><span class="op">.</span><span class="fu">max</span>()<span class="op">;</span> <span class="co">// -Infinity</span></span></code></pre></div></code></pre>
<p><code>Math.max</code> is a variadic function, meaning you can call it with 1, 2, 3 or 0 arguments. When called with 0 arguments, it returns <code>-Infinity</code>. Why? Because maximum of an empty set is negative infinity.</p>
<p>Why not throw an arity error on 0 arguments you ask? Because there are cases where the number of arguments isn&#39;t known at compile time. For example, calling it with the spread operator like <code>Math.max(...myArgs)</code>. In fact, try implementing <code>Math.max</code> yourself, how would you do it?</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="bu">Math</span><span class="op">.</span><span class="fu">max</span> <span class="op">=</span> (args<span class="op">...</span>) <span class="kw">=&gt;</span> {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> maxSoFar <span class="op">=</span> <span class="co">/* what? */</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    args<span class="op">.</span><span class="fu">forEach</span>(arg <span class="kw">=&gt;</span> {</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> (arg <span class="op">&gt;</span> maxSoFar) maxSoFar <span class="op">=</span> arg<span class="op">;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxSoFar<span class="op">;</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></code></pre>
<p>What should <code>maxSoFar</code> be initialized with? What is that one value which is guaranteed to be less than any number? <code>-Infinity</code>, of course. We can&#39;t initialize it with <code>args[0]</code> here because the index may be out of bounds, when <code>args</code> is empty. Another approach could be:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="bu">Math</span><span class="op">.</span><span class="fu">max</span> <span class="op">=</span> (args<span class="op">...</span>) <span class="kw">=&gt;</span> {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> (args<span class="op">.</span><span class="at">length</span> <span class="op">&lt;</span> <span class="dv">1</span>) <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&quot;Expected at least 1 argument&quot;</span>)<span class="op">;</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>   <span class="co">// ...</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></code></pre>
<p>Personally, I&#39;d prefer something like this, but I&#39;m okay with the existing <code>max</code> function too.</p>
<p>Finally,</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] <span class="op">==</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span></code></pre></div></code></pre>
<p>This is a result of referential equality, heap allocation, and a lack of operator overriding.
This behaviour is common across most general purpose languages (with the exception of Python).</p>
<p>Beyond these common expressions, I&#39;ve seen other misinformed takes on the language.
For instance:</p>
<h2 id="javascript-is-slow">JavaScript is slow.</h2>
<p>Programming languages do not have performance characteristics.
Their implementations do.
Python isn&#39;t inherently a slow language, though its interpreter(CPython) might be.
Using a different implementation (Numba, PyPy, Cinder, etc.) will always react differently to benchmarks.</p>
<p>That said, the design of a language can heavily influence its general performance, across implementations.
Languages that exhibit highly dynamic behaviour are difficult to optimize, and therefore tend to be slower than their compiled friends.</p>
<p>Some of the most vital JavaScript engines today, V8, JSC, Hermes, and SpiderMonkey are extremely performant, optimizing beasts. They&#39;re JIT compilers, the precise inner workings of which warrant an essay of their own.</p>
<p>Taking a look at some benchmarks from the <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">computer language benchmark games</a> site, it would appear that Node.js (which embeds V8) is actually not bad at all, even beating some implementations of Java, Haskell, and C++ (!?).</p>
<p>Of course, Benchmarks do not represent real world programs.
You don&#39;t use JavaScript to crunch high volumes of data, or do automatic differentiation (If you do, I urge you to reconsider).
You use JavaScript to color buttons on a webpage.</p>
<h2 id="javascript-is-untyped-and-unsafe">JavaScript is untyped, and unsafe.</h2>
<p>No. JavaScript is <strong>dynamically checked</strong> and <strong>safe</strong>.
Take this excerpt out of Pierce&#39;s book, <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">Types and programming languages</a>:</p>
<blockquote>
<p>Terms like &quot;dynamically typed&quot; are arguably misnomers and should probably be replaced by &quot;dynamically checked,&quot; but the usage is standard.</p>
</blockquote>
<p><strong>Dynamically checked:</strong> Variables and symbols do <strong>not</strong> have types. The types are bound to <strong>values</strong> instead.</p>
<p>Let&#39;s try with an example. The number <code>100</code>, has a type of &quot;number&quot; at runtime. However in this statement:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span></code></pre></div></code></pre>
<p>The <strong>symbol</strong> &quot;x&quot; and in it&#39;s semantic definition, does not have a type. But it&#39;s still not wrong to say <em>&quot;the type of &#39;x&#39; is <code>number</code>&quot;</em>. Why? Because when <code>x</code> is evaluated by the runtime, as a <strong>value</strong>, it does have a type (which can be seen by evaluating <code>typeof x</code>).</p>
<p>However the <strong>name</strong> &quot;x&quot; is void of any type. So we can do <code>x = &#39;xyz&#39;</code> and the interpreter will happily run it.</p>
<p>The key is to understand the difference between the <strong>name</strong> &#39;&#39;x&quot; which can be bound to any value, and the <strong>value</strong> &quot;x&quot;, which always evaluates to whichever value the name is bound to at the time of evaluation.</p>
<p><strong>Safety</strong>: The most commonly accepted definition of safety is:
<em>A language where every code snippet always is well-defined by the standard.</em></p>
<p>And this is indeed true of JavaScript. If you don&#39;t like that thought, pause for a second and try to come up with a JavaScript code snippet that is <strong>undefined</strong> under the ECMAScript spec. You&#39;ll find that none exist. It may error out, or produce wonky output, but the behaviour is <strong>defined</strong>, and will be the same for every standard-compliant JavaScript implementation.</p>
<p>In fact, C++ is <strong>less safe</strong> than JavaScript, despite being statically typed (which makes sense, because typing and safety are orthogonal). For example, the following C++ code does not have any defined behaviour:</p>
<code class="language-cpp"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> IntOrPtr <span class="op">{</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> integer<span class="op">;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> ptr<span class="op">;</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>  IntOrPtr u <span class="op">=</span> <span class="op">{</span> <span class="op">.</span>ptr <span class="op">=</span> <span class="st">&quot;some string&quot;</span> <span class="op">};</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> u<span class="op">.</span>integer <span class="op">&lt;&lt;</span> <span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span><span class="op">;</span> <span class="co">// &lt;--- Whoops!</span></span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></code></pre>
<p>Accessing the uninitialized field of a union is undefined behavior, and may have different behavior on different compilers, hardware, OS, or different runs of the same executable.</p>
<table>
<thead>
<tr>
<th></th>
<th>Safe</th>
<th>Unsafe</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Dynamic checking</strong></td>
<td>Easy to write erroneous code, but easier to debug due to well defined runtime behavior and inspection capability.</td>
<td>Don&#39;t know of any such languages except hobby projects.</td>
</tr>
<tr>
<td><strong>Static checking</strong></td>
<td>Best of both worlds. Most languages in this bucket are either functional, or r***-like.</td>
<td>Easier to write correct programs, but harder to debug as there are no types and bounds at runtime.</td>
</tr>
</tbody>
</table>
<p>There is always a tradeoff.
If you miss having compile time type checking when writing JS, maybe try Typescript/Purescript?</p>
<h3 id="javascript-is-single-threaded-hence-bad">JavaScript is single threaded, hence bad.</h3>
<p>I don&#39;t disagree with this one.</p>
<p>Thankfully V8 (and <del>NodeJS</del> libuv) are designed well enough that this problem is easily circumvented with asynchronous code.</p>
<p>Some languages have built-in multithreading support, like atomic data types, or operators that spawn threads/processes.
Others bake threading support into their standard libraries (<code>pthread</code>).
JavaScript falls in the second category.</p>
<h3 id="not-all-roses">Not all roses.</h3>
<p>Ok, now that I&#39;m done playing the devil&#39;s advocate,
I do have my own fair share of complaints.</p>
<ol>
<li>
<p>Starting off on an easier foot, the <code>var</code> keyword. ECMA&#39;s unwillingness to forsake backwards compatibility has led to some very annoying legacy cruft in JS that just won&#39;t go away. <strong>Function scope</strong> is one of those.</p>
</li>
<li>
<p><strong>Too much implicit type-coercion</strong>. The type system is incorrigibly broken. Everything can coerce into Everything, and the runtime will jump through all kinds of hoops before throwing an error.</p>
</li>
<li>
<p><strong>Wonky whitespace sensitivity.</strong>
JavaScript looks like it&#39;s not white-space sensitive at first glance. Catch this:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">124</span> <span class="co">// ok</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="dv">100</span> <span class="co">// ok</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">124</span> d <span class="op">=</span> <span class="dv">214</span> <span class="co">// NOT OK</span></span></code></pre></div></code></pre>
<p>That&#39;s right, it isn&#39;t really white-space sensitive at all. I wish the language had simpler rules regarding this, but that&#39;s unfortunately not the case. So we rely on linters to warn us. (This ties into the next point).</p>
</li>
<li>
<p><strong>Automatic semi-colon insertion</strong>. What you&#39;re seeing above is really an effect of <a href="https://262.ecma-international.org/7.0/#sec-rules-of-automatic-semicolon-insertion">this</a> annoying ECMA ruleset. So behold:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ten</span>() {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">10</span><span class="op">;</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="fu">ten</span>())<span class="op">;</span> <span class="co">// undefined</span></span></code></pre></div></code></pre>
<p>This not very obvious when your functions are deeply nested and the expression is big, like:</p>
<code class="language-javascript"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">foo</span>() {</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="op">..</span>) {</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="op">..</span>) {</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (<span class="op">...</span>) {</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (<span class="op">...</span>) {</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// not doing what you think it&#39;s doing</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>                    	GetFooFactory<span class="op">.</span><span class="fu">MakeFoo</span>(<span class="fu">MakeBar</span>(<span class="fu">Baz</span>(Pop<span class="op">,</span> Bop)))</span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>                }</span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></code></pre>
</li>
<li>
<p><strong>Contextual keywords</strong>. <code>async</code>, <code>await</code> and even <code>let</code> are keywords under some contexts and identifiers under others. This leads to some funny possibilities like <code>var let = 100</code>. Although not inherently bad, I still dislike them personally because of it&#39;s inconsistent nature.</p>
</li>
<li>
<p><strong>Unused reserved words</strong>. <code>enum</code>, <code>private</code>, <code>public</code> are reserved words that you cannot use. But they don&#39;t bring any features to the language. ECMA just <em>might</em> one day add private members or enums and so they reserved these words. I see this as a good strategy, but why not do one thing? If you have contextual keywords, then make these keywords contextual too instead of &quot;pre-reserving&quot; them and making other future keywords contextual. That said, I see this as a reasonable approach. Although I don&#39;t quite understand why implementing enums is taking so long :p</p>
</li>
<li>
<p><strong>Hoisting</strong>. Not a big deal, but not WSYIWYG. I like my scripting languages WSYIWYG, thank you.</p>
</li>
</ol>
<p>If you want more, try <a href="https://wtfjs.com/">wtfjs</a>.</p>


      <script src="https://utteranc.es/client.js" repo="srijan-paul/srijan-paul.github.io" label="blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
      </script>
    </div>

    <script src="/util.js"></script>
    <script>
      const dateElement = document.querySelector(".post-date");
      dateElement.innerText = dateToString(new Date("2021-07-18"), true);
    </script>
  </body>
</html>

