<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
    <meta name="description" content="Dynamic programming in Haskell with lazy evaluation"></meta>
    <meta property="og:title" content="Intro to lazy evaluation and functional DP"></meta>
    <meta property="twitter:title" content="Intro to lazy evaluation and functional DP"></meta>
    <meta property="twitter:description" content="Dynamic programming in Haskell with lazy evaluation"></meta>

     
    <meta property="og:image" content></meta>
		<meta name="twitter:image" content>
    

    <meta property="og:site_name" content="InJuly"></meta>

    <link rel="stylesheet" href="/assets/css/common.css">
    <link rel="stylesheet" href="/assets/css/post.css">
    <link rel="stylesheet" href="/assets/css/theme.css">
    

    <script data-goatcounter="https://injuly.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>


    <title>Intro to lazy evaluation and functional DP</title>
  </head>

  <body>
    <div class="main">
      <div class="nav">
        <div class="nav-left">
          <a id="home-link" href="/">injuly</a>
        </div>

        <div class="nav-right">
          <a href="/" class="nav-link">index</a>
          <a href="/about" class="nav-link">about</a>
          <a href="/blog" class="nav-link">blog</a>
          <a href="/now" class="nav-link">now</a>
        </div>
      </div>

      <hr>

      <div class="leader">
        <h2> Intro to lazy evaluation and functional DP </h2>
        <div class="post-date"></div>
        <span class="tags" id="tags">
            <a class="tag" href="/posts/index.html?tag=post">post</a>
            <a class="tag" href="/posts/index.html?tag=haskell">haskell</a>
            <a class="tag" href="/posts/index.html?tag=project-euler">project-euler</a>
        </span>
      </div>
      <p>Functional languages are assumed to be inferior at tackling problems
that are best solved with dynamic programming.
This belief is largely based on the absence of state and mutation from pure languages.
It is true that DP often requires a global state (the memoization table),
and continuous updates to the said state.</p>
<p>With lazy evaluation, however, a declarative solution&#39;s elegance far supersedes its imperative counterparts.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>
approach to any problem involves finding solutions to smaller sub-problems
of similar nature, and then combining them to obtain the answer.</p>
<p>Consider the Fibonacci sequence for example:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> fib (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib (n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div></code></pre>
<p>Most imperative solutions to computing the Nth Fibonacci number would
involve a table of some sort, where each number <code>i</code> is mapped to <code>Fib_i</code>.
The first two items in the table are set to 0 and 1 (or 1 and 2), and the
program then iterates over the size of the table, setting <code>fib[i]</code> to <code>fib[i - 1] + fib[i - 2]</code>.
One such solution is discussed
<a href="https://www.baeldung.com/cs/fibonacci-top-down-vs-bottom-up-dynamic-programming">here</a>.</p>
<h2 id="project-euler-2">Project Euler #2</h2>
<p>This is the question posed in <a href="https://projecteuler.net/problem=2">problem 2</a>
of the <a href="https://projecteuler.net/">Project Euler archive</a>:</p>
<code class="language-md"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>A new term in the Fibonacci sequence is generated by adding the previous two.</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>Starting with 1 and 2, the first 10 terms will be:</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>Considering the terms in the Fibonacci sequence whose values do not exceed </span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>four million, find the sum of the even-valued terms</span></code></pre></div></code></pre>
<p>Over the remainder of this post, we&#39;ll go over two solutions to this challenge -
an obvious solution using python, and a slightly more elegant approach in Haskell.</p>
<p>The goal is to understand lazy evaluation and functional DP.
Prior knowledge of Haskell will help, but isn&#39;t necessary.</p>
<h2 id="imperative-solution">Imperative solution</h2>
<p>There is not much to go over with this one:</p>
<code class="language-python"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sum_even_fibs_below(n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    fibs_cache <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">40</span>))</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, <span class="bu">len</span>(fibs_cache)):</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>       fibs_cache[i] <span class="op">=</span> fibs_cache[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> fibs_cache[i <span class="op">-</span> <span class="dv">2</span>]</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    sieve <span class="op">=</span> <span class="kw">lambda</span> x: x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> x <span class="op">&lt;</span> n</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(<span class="bu">filter</span>(sieve, fibs_cache))</span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(sum_even_fibs_below(<span class="dv">4000000</span>))</span></code></pre></div></code></pre>
<p>First, we have <code>fibs_cache</code> - a standard DP table that we update in <code>O(n)</code> time.
Then we filter out entries that are even (or larger than 4M),
and sum over the list.</p>
<p>Mark the presence of a &quot;state&quot; object in the python program -
namely, the <code>fibs_cache</code> list.
We update the items in this cache within a loop.</p>
<p>The rest of the operations in the code are stateless and referentially transparent.
To implement memoization, we&#39;re going to leverage two features of Haskell:</p>
<ol>
<li>Lazy evaluation.
</li>
<li>Infinite lists.
</li>
</ol>
<p>The second is really just a natural consequence of the first.</p>
<h2 id="lazy-evaluation">Lazy evaluation</h2>
<p>Haskell is a lazily evaluated language, wherein no value is evaluated until it&#39;s needed.
To understand what this means, consider the following snippet:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a <span class="ot">=</span> get_a () <span class="co">-- takes 1 seconds to compute</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">=</span> get_b () <span class="co">-- takes 2 seconds to compute</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    c <span class="ot">=</span> get_c () <span class="co">-- takes 3 seconds to compute</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span> <span class="fu">print</span> (a <span class="op">+</span> b)<span class="co">-- takes 1 + 2 = 3 seconds</span></span></code></pre></div></code></pre>
<p>When we call <code>print</code>, the expression <code>a + b</code> <em>must</em> be evaluated so that it can be written to stdout.
Before the runtime encounters the call to <code>print</code>, however, <code>a</code>, <code>b</code> and <code>c</code> remain &quot;frozen&quot;.</p>
<p>Since we made the assumption that <code>get_a</code> and <code>get_b</code> require 1 and 2 seconds
to compute, <code>a + b</code> will block the thread for a total of 3 seconds, whereas <code>get_c</code> will never be visited.</p>
<p>Here we notice Haskell&#39;s ability to leave chunks of code unevaluated until necessary.
This will turn out to be our cornerstone in tackling dynamic programming problems
with a functional arsenal.</p>
<h3 id="infinite-lists">Infinite lists</h3>
<p>Lazy evaluation enables a neat trick - infinite lists.
Fire up the <code>ghci</code> REPL and enter the following expression:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="op">..</span>]</span></code></pre></div></code></pre>
<p>You will notice that the REPL infinitely prints contents of this list until halted.
If you bind to a variable, however, the REPL won&#39;t evaluate it right away:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> xs <span class="ot">=</span> [<span class="dv">1</span>, <span class="dv">2</span> <span class="op">..</span>]</span></code></pre></div></code></pre>
<p>We can use <code>xs</code> like a regular linked list:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> xs <span class="op">!!</span> <span class="dv">4</span></span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="fu">takeWhile</span> (<span class="op">&lt;</span> <span class="dv">5</span>) xs</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span></code></pre></div></code></pre>
<p>To understand the &quot;laziness&quot; better, let&#39;s strip away the syntactic sugar.
Without list comprehensions, we can write <code>xs</code> this way:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">xs ::</span> [<span class="dt">Int</span>]</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>xs <span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> next xs</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    next (x <span class="op">:</span> rest) <span class="ot">=</span> (x <span class="op">+</span> <span class="dv">1</span>) <span class="op">:</span> next rest</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    next [] <span class="ot">=</span> []</span></code></pre></div></code></pre>
<p>We tell Haskell that <code>xs</code> is a linked list where the first item is <code>1</code>,
and the rest of the items are given by the function call: <code>next xs</code>.
Since Haskell is lazy, it won&#39;t make the effort to actually evaluate <code>next xs</code>.
This self reference of <code>xs</code> is therefore considered safe.</p>
<p>However, when we ask for the <code>nth</code> element in <code>xs</code>, the runtime will start
iterating over the list, evaluating the values and chasing pointers until it
reaches the desired slot.</p>
<p>Visually, an infinite list can be thought of as a linked list where the head is some value,
and the body is a &quot;frozen&quot; computation which returns the rest of the list upon thawing.
Calling <code>tail xs</code> will take a step forward and return <code>2 -&gt; [ ... ]</code>.
Calling <code>tail $ tail xs</code> will take 2 steps forward, and return <code>3 -&gt; [...]</code>.</p>
<p>To get comfortable, try working this out on paper.</p>
<h2 id="an-infinite-list-in-python">An infinite list in Python</h2>
<p>Python is not lazy, but we can emulate infinite lists with some effort.
This is purely to build an intuition for the subject, and is not idiomatic Python code.</p>
<p>We start by defining <code>make_list</code> - a function that returns an infinite list.
Later, we&#39;re going to define <code>rest</code> and <code>index_list</code>, to mirror Haskell&#39;s <code>tail</code> and <code>(!!)</code> functions.</p>
<code class="language-python"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_list(first_item):</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="co">    Create an infinite list where every item</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="co">    is greater than the last by 1 </span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">=</span> [<span class="kw">lambda</span>: first_item]</span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a>    xs.append(rest(xs))</span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> xs</span></code></pre></div></code></pre>
<p>To get around the lack of self-references in the language,
we exploit the fact that non-primitives are stored by reference.
i.e - The second element of <code>xs</code> can store a reference to <code>xs</code>.</p>
<p>Every element in <code>xs</code> is a function.
This is to prevent the interpreter from eagerly evaluating the values returned by the function.
The first element is simply the head of the list, and
the second element is a function that, when called, returns the body of <code>xs</code>.</p>
<p>Next, we define <code>rest</code> like so:</p>
<code class="language-python"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rest(xs):</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns the body of a linked list, minus the head.</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">lambda</span>: [<span class="kw">lambda</span>: xs[<span class="dv">0</span>]() <span class="op">+</span> <span class="dv">1</span>, rest(xs[<span class="dv">1</span>])]</span></code></pre></div></code></pre>
<p>It looks gnarly at first, but becomes easier to grasp once you realize that we&#39;re really
just using <code>lambda</code> to &quot;freeze&quot; a value. The interpreter won&#39;t evaluate a frozen value
unless we &quot;thaw&quot; it using the call operator - <code>()</code>.</p>
<p>At any given moment, our list always contains two items:</p>
<ol>
<li>A &quot;frozen&quot; head.
</li>
<li>A &quot;frozen&quot; body, containing an unevaluated recursive call to <code>rest</code>.
This will again return a 2-element list of the same shape.
</li>
</ol>
<p>You could imagine the function <code>rest</code> as a taking a step forward in our linked-list:</p>
<code><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>rest [1, &lt;...&gt;] = [2, &lt;...&gt;]</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>rest [2, &lt;...&gt;] = [3, &lt;...&gt;]</span></code></pre></div></code></pre>
<p>Next, we define two simple helpers:</p>
<code class="language-python"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> head(xs):</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Returns the head of an infinite list&quot;&quot;&quot;</span></span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> xs[<span class="dv">0</span>]()</span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a></span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> index_list(xs, i):</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a><span class="co">    Get the ith item in an infinite list</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>    curr <span class="op">=</span> xs</span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>        curr <span class="op">=</span> rest(curr)()</span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> head(curr)</span></code></pre></div></code></pre>
<p>With that, we have an infinite list  similar to the one we wrote in Haskell.</p>
<code class="language-python"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a>xs <span class="op">=</span> make_list(<span class="dv">1</span>)</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(index_list(xs, <span class="dv">100</span>)) <span class="co"># 101</span></span></code></pre></div></code></pre>
<h2 id="an-infinite-list-to-draw-fibonacci-numbers-from">An infinite list to draw Fibonacci numbers from</h2>
<p>We&#39;ve established that infinite lists are really just regular values
that are left unevaluated thanks to Haskell&#39;s lazy nature.</p>
<p>By now, an infinite list that stores Fibonacci numbers should be easy to digest:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">fibs ::</span> [<span class="dt">Int</span>]</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>fibs <span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">2</span> <span class="op">:</span> next fibs</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    next (x <span class="op">:</span> xs) <span class="ot">=</span> (x <span class="op">+</span> <span class="fu">head</span> xs) <span class="op">:</span> next xs</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    next _ <span class="ot">=</span> []</span></code></pre></div></code></pre>
<p>If this is still confusing, try working out the evaluation of <code>fibs !! 4</code> on paper.
You&#39;ll see that the <code>fibs</code> list is nearly identical to <code>xs</code>.</p>
<p>In the problem, we are asked to find out the sum of all even fibonacci numbers
that are less than 4000000. Try taking a stab at it before reading ahead.</p>
<p>You&#39;ll see that all we need to do now is translate the Python solution to Haskell.</p>
<ol>
<li>Keep pulling items out of <code>fibs</code> until we hit a number larger than 4 million.
</li>
<li>Filter out all the odd numbers.
</li>
<li>Sum over the remaining numbers.
</li>
</ol>
<p>Here is the full solution, around 12 lines of haskell:</p>
<code class="language-hs"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span id="1"><a href="#1" aria-hidden="true" tabindex="-1"></a><span class="ot">fibs ::</span> [<span class="dt">Int</span>]</span>
<span id="2"><a href="#2" aria-hidden="true" tabindex="-1"></a>fibs <span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">2</span> <span class="op">:</span> next fibs</span>
<span id="3"><a href="#3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="4"><a href="#4" aria-hidden="true" tabindex="-1"></a>    next (x <span class="op">:</span> xs) <span class="ot">=</span> (x <span class="op">+</span> <span class="fu">head</span> xs) <span class="op">:</span> next xs</span>
<span id="5"><a href="#5" aria-hidden="true" tabindex="-1"></a>    next _ <span class="ot">=</span> []</span>
<span id="6"><a href="#6" aria-hidden="true" tabindex="-1"></a></span>
<span id="7"><a href="#7" aria-hidden="true" tabindex="-1"></a><span class="ot">sumEvenFibsBelow ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="8"><a href="#8" aria-hidden="true" tabindex="-1"></a>sumEvenFibsBelow n <span class="ot">=</span> <span class="fu">sum</span> evenFibsBelowN</span>
<span id="9"><a href="#9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="10"><a href="#10" aria-hidden="true" tabindex="-1"></a>    evenFibsBelowN <span class="ot">=</span> <span class="fu">filter</span> <span class="fu">even</span> fibsBelowN</span>
<span id="11"><a href="#11" aria-hidden="true" tabindex="-1"></a>    fibsBelowN <span class="ot">=</span> <span class="fu">takeWhile</span> (<span class="op">&lt;</span> n) fibs</span>
<span id="12"><a href="#12" aria-hidden="true" tabindex="-1"></a></span>
<span id="13"><a href="#13" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="14"><a href="#14" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> sumEvenFibsBelow <span class="dv">4000000</span></span></code></pre></div></code></pre>
<p>Of course, fibonacci series is only a basic introduction to dynamic programming.
Other problems of similar nature can also be modelled on top of lazy lists.
As an exercise, you could try attempting
<a href="https://leetcode.com/problems/climbing-stairs/">this leetcode problem</a>
using memoization and infinite lists.</p>
<h2 id="references">References</h2>
<ol>
<li><a href="https://www.baeldung.com/cs/fibonacci-top-down-vs-bottom-up-dynamic-programming">Baeldung - Fibonacci using top down vs bottom up DP</a>
</li>
<li><a href="https://wiki.haskell.org/Lazy_evaluation">Haskell wiki - Lazy evaluation</a>
</li>
</ol>


      <script src="https://utteranc.es/client.js" repo="srijan-paul/srijan-paul.github.io" label="blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
      </script>
    </div>

    <script src="/util.js"></script>
    <script>
      const dateElement = document.querySelector(".post-date");
      dateElement.innerText = dateToString(new Date("2022-08-16"), true);
    </script>
  </body>
</html>
